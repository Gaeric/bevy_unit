#+title: tips
#+startup: content
#+author: Gaeric
#+HTML_HEAD: <link href="./worg.css" rel="stylesheet" type="text/css">
#+HTML_HEAD: <link href="/static/css/worg.css" rel="stylesheet" type="text/css">
#+OPTIONS: ^:{}
** debug调试
   开启trace级别日志

   RUST_BACKTRACE=full RUST_LOG=trace cargo run -r --example minimal
** note
*** insert resource from main world and use them for render world
    #+begin_src rust-ts
      // bevy v0.9

      let noise_path = self.noise_folder.clone();
      let load_system = move |mut commands: Commands, asset_server: Res<AssetServer>| {
          let handles = (0..NOISE_TEXTURE_COUNT)
              .map(|id| {
                  let name = format!("{}/LDR_RGBA_{}.png", noise_path, id);
                  asset_server.load(&name)
              })
              .collect();
          commands.insert_resource(NoiseTexture(handles));
      };

      fn extract_noise_texture(mut commands: Commands, noise_texture: Extract<Res<NoiseTexture>>) {
          commands.insert_resource(noise_texture.clone());
      }
    #+end_src

    #+begin_src rust-ts
      fn extract_noise_texture(mut commands: Commands, noise_texture: Extract<Res<NoiseTexture>>) {
          commands.insert_resource(noise_texture.clone());
      }

      // 可以参考GameOfLife中的写法，直接使用ExtractPlugins等效替代
      #[derive(Clone, Deref, DerefMut, ExtractResource)]
      pub struct NoiseTexture(pub Vec<Handle<Image>>);

      app.add_plugin(ExtractResourcePlugin::<NoiseTexture>::default());
    #+end_src
*** 使用parse库和宏来减少冗余代码
    见于parse文档： https://docs.rs/paste/latest/paste/

    示例：
    #+begin_src rust-ts
      macro_rules! create_modular_segment {
          ($name:ident) => {
              paste::paste! {
                  #[derive(Debug, Component)]
                  pub struct [<ModularCharacter $name>] {
                      pub id: usize,
                      pub instance_id: Option<InstanceId>,
                      pub entities: Vec<Entity>,
                  }
                  impl ModularCharacter for [<ModularCharacter $name>] {
                      fn id_mut(&mut self) -> &mut usize {
                          &mut self.id
                      }

                      fn instance_id_mut(&mut self) -> &mut Option<InstanceId> {
                          &mut self.instance_id
                      }

                      fn entities_mut(&mut self) -> &mut Vec<Entity> {
                          &mut self.entities
                      }

                      fn id(&self) -> &usize {
                          &self.id
                      }

                      fn instance_id(&self) -> Option<&InstanceId> {
                          self.instance_id.as_ref()
                      }

                      fn entities(&self) -> &Vec<Entity> {
                         &self.entities
                      }
                  }
              }
          };
      }
    #+end_src

    这段代码创建了一个create_modular_segment的宏，用这个宏来生成ModularCharacterXx的组件，由于每个组件的写法基本相同，这个方法可以减少大重的冗余代码。

    在这个宏中，使用paste宏拼接了[<>]中的字符串，然后为这个Component生成ModularCharacter需要的方法
*** 指定某个crate版本
    调试leafwing-input-manager时，发现leafwing-input-manager这个crate加入项目后，本地无法正常编译，但是在原始项目仓库中没有问题。

    经过简单验证，怀疑可能是因为指定项目使用了本地bevy crate，而leafwing-input-manager此时使用的仍然是crate.io中的依赖，导致了编译问题。

    由此，使用patch方法修改bevy版本

    #+begin_example
      [dependencies]
      bevy = "0.16.0"
      leafwing-input-manager = "0.17.0"

      [patch.crates-io]
      bevy = { path = "../bevy_engines/bevy_0.16/" }
    #+end_example

    修改后，发现需要编译的crate数量明显减少，且编译不再报错。

    在一个工作区中，只需要在工作区的根路径中指定crate的patch，工作区中所有子crate都会使用该patch版本进行编译，包括crate的依赖项

    修改完成后，可使用cargo tree检查依赖关系，或直接查看cargo.lock
    #+begin_example
      # 不使用patch指定本地版本
      cargo tree | grep bevy_platform
      │       │   │   │   ├── bevy_platform v0.16.0
      │       │   │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   │   ├── bevy_platform v0.16.0 (*)
      │       ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │       │   ├── bevy_platform v0.16.0 (*)
      │           ├── bevy_platform v0.16.0 (*)

      使用patch指定本地版本

      zero@work ~/d/b/action_demo > cargo tree | grep bevy_platform
      │       │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │       │   ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
      │           ├── bevy_platform v0.16.0 (/home/**/**/bevy_0.16/crates/bevy_platform) (*)
    #+end_example

    在使用crate时，如果某个crate仅指定了使用bevy的子crate，这个子crate需要单独设置patch
*** 将app的log写入文件
    https://github.com/bevyengine/bevy/issues/5233
*** 指定某个crate和module的打印级别
    使用如下语句：
    RUST_LOG="crate::module=debug" cargo run

    例：
    RUST_LOG="bevy_shine=debug" cargo run --example minimal
*** hot patch
    bevy目前使用dioxus-cli工具链用于hot patch

    命令形式形如：BEVY_ASSET_ROOT="." dx serve --hot-patch --example feathers --features="experimental_bevy_feathers,hotpatching"

    注意需要使用BEVY_ASSET_ROOT，以便于正常加载资源文件

    如果需要动态加载asset资产，需要同时启用file_watcher和asset_processor，参考：

    cargo run --example extended_material --features="file_watcher asset_processor"
*** ecs note
    ecs中update函数在对应schedule时一定执行，并不依赖于Query中的查询结果，验证代码如下：
    #+begin_src rust-ts
      fn check_archetype(query: Query<&PrivateCheck>) {
          info!("check for archetype filter")
      }

      fn check_added(query: Query<Entity, Added<PrivateCheck>>) {
          info!("check for added")
      }

      #[derive(Component)]
      struct PrivateCheck;

      pub fn plugin(app: &mut App) {
          app.add_systems(Update, check_added)
              .add_systems(Update, check_archetype);
      }
    #+end_src

    使用for方式获取query的结果，才会受到query查询的影响

    或者使用single方式查询，在组件不存在时跳过该system
    #+begin_src rust-ts
      /// [System parameter] that provides access to single entity's components, much like [`Query::single`]/[`Query::single_mut`].
      ///
      /// This [`SystemParam`](crate::system::SystemParam) fails validation if zero or more than one matching entity exists.
      /// This will cause the system to be skipped, according to the rules laid out in [`SystemParamValidationError`](crate::system::SystemParamValidationError).

      fn check_archetype(query: Single<&PrivateCheck>) {
          info!("check for archetype filter")
      }
    #+end_src
*** 使用cargo expand
    cargo expand可以展开代码中的宏，可以通过检查展开后的宏，来确认一些关键参数，或用于理解宏过程。

    安装：sudo pacman -S cargo-expand

    使用：cargo expand --example example-manual-materials
