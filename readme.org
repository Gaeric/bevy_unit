#+title: Bevy Unit
#+startup: content
#+author: Gaeric
#+HTML_HEAD: <link href="./worg.css" rel="stylesheet" type="text/css">
#+HTML_HEAD: <link href="/static/css/worg.css" rel="stylesheet" type="text/css">
#+OPTIONS: ^:{}
* Intro
  这个仓库用来记录我学习或拓展的bevy的某个示例
** modular character
   这个示例展示了如何将多个使用相同骨骼或基于同一套骨骼拆分出的各个子模块拼接到一起，并播放完整动画的功能。

   其技术原理为：获取完整的人物骨架，将各个子骨架按名称重新将从属关系绑定至完整骨架上。
*** DONE animations
    可以获取到正常的AnimationClip，但是不知道应该如何正常在拼接好的人物上播放动画，有待后续继续深入了解。

    在discord上求助后，我发现存在原始代码可能存在的两个问题：

    1. clip需要进行处理，生成AnimationGraph并插入到该实体中
    2. 可能需要使用transitions来播放动画

    经过上面两个小点的调整之后，我成功播放了动画，以下是动画播放部分的代码
    #+begin_src rust-ts
      pub fn run_animations(
          mut commands: Commands,
          mut animation_players_query: Query<&mut AnimationPlayer>,
          scene_and_animation_player_link_query: Query<
              (&SceneName, &AnimationEntityLink),
              Added<AnimationEntityLink>,
              >,
          animations: Res<Animations>,
          scene_entities_by_name: Res<SceneEntitiesByName>,
          mut graphs: ResMut<Assets<AnimationGraph>>,
      ) {
          let main_skeleton_scene_entity = scene_entities_by_name
              .0
              .get("modular_character/main_skeleton.glb")
              .expect("the scene to be registered");

          let (_, animation_player_entity_link) = scene_and_animation_player_link_query
              .get(*main_skeleton_scene_entity)
              .expect("the scene to exist");

          let mut animation_player = animation_players_query
              .get_mut(animation_player_entity_link.0)
              .expect("to have an animation player on the main skelection");

          let animation_clip = animations
              .0
              .get("Sword_Slash")
              .expect("to have sword_slash")
              .clone_weak();

          let (graph, animation_index) = AnimationGraph::from_clip(animation_clip);

          let graph_handle = graphs.add(graph);

          let mut transitions = AnimationTransitions::new();

          transitions
              .play(&mut animation_player, animation_index, Duration::ZERO)
              .repeat();

          commands
              .entity(animation_player_entity_link.0)
              .insert(graph_handle)
              .insert(transitions);
      }
    #+end_src
*** reference
    @see 
    https://github.com/SnowdenWintermute/bevy-modular-characters-proof-of-concept
** fps ui
   一个提示帧数的UI库

   https://github.com/IyesGames/iyes_perf_ui
** bevy_shine
   学习如何在最新的bevy库上，使用路径追踪技术构建全局光照

   详细信息记录于bevy_shine crate中
** render_graph
   在bevy 0.12中验证确认，Camera指定的render_graph后，渲染流程仅遵循指定的render_graph运行

   #+begin_src rust-ts
     commands.spawn(Camera3dBundle {
         camera_render_graph: CameraRenderGraph::new(my_plugin::graph::NAME),
         transform: Transform::from_xyz(-2.0, 2.5, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
         ..Default::default()
     });
   #+end_src

   如上所示，如果指定了Camera3dBundle的render_graph为my_plugin中的render_graph，则渲染过程完全按照render graph中的节点顺序进行。
** viewtarget
   在bevy 0.12版本中，UpscalingNode节点能正常向窗口输出最终图像

   需要使用ViewTarget结构的out_texture做为RenderPassColorAttachment的view输出
