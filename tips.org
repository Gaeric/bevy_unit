#+title: tips
#+startup: content
#+author: Gaeric
#+HTML_HEAD: <link href="./worg.css" rel="stylesheet" type="text/css">
#+HTML_HEAD: <link href="/static/css/worg.css" rel="stylesheet" type="text/css">
#+OPTIONS: ^:{}
** debug调试
   开启trace级别日志

   RUST_BACKTRACE=full RUST_LOG=trace cargo run -r --example minimal
** note
*** insert resource from main world and use them for render world
    #+begin_src rust-ts
      // bevy v0.9

      let noise_path = self.noise_folder.clone();
      let load_system = move |mut commands: Commands, asset_server: Res<AssetServer>| {
          let handles = (0..NOISE_TEXTURE_COUNT)
              .map(|id| {
                  let name = format!("{}/LDR_RGBA_{}.png", noise_path, id);
                  asset_server.load(&name)
              })
              .collect();
          commands.insert_resource(NoiseTexture(handles));
      };

      fn extract_noise_texture(mut commands: Commands, noise_texture: Extract<Res<NoiseTexture>>) {
          commands.insert_resource(noise_texture.clone());
      }
    #+end_src

    #+begin_src rust-ts
      fn extract_noise_texture(mut commands: Commands, noise_texture: Extract<Res<NoiseTexture>>) {
          commands.insert_resource(noise_texture.clone());
      }

      // 可以参考GameOfLife中的写法，直接使用ExtractPlugins等效替代
      #[derive(Clone, Deref, DerefMut, ExtractResource)]
      pub struct NoiseTexture(pub Vec<Handle<Image>>);

      app.add_plugin(ExtractResourcePlugin::<NoiseTexture>::default());
    #+end_src
*** 使用parse库和宏来减少冗余代码
    见于parse文档： https://docs.rs/paste/latest/paste/

    示例：
    #+begin_src rust-ts
      macro_rules! create_modular_segment {
          ($name:ident) => {
              paste::paste! {
                  #[derive(Debug, Component)]
                  pub struct [<ModularCharacter $name>] {
                      pub id: usize,
                      pub instance_id: Option<InstanceId>,
                      pub entities: Vec<Entity>,
                  }
                  impl ModularCharacter for [<ModularCharacter $name>] {
                      fn id_mut(&mut self) -> &mut usize {
                          &mut self.id
                      }

                      fn instance_id_mut(&mut self) -> &mut Option<InstanceId> {
                          &mut self.instance_id
                      }

                      fn entities_mut(&mut self) -> &mut Vec<Entity> {
                          &mut self.entities
                      }

                      fn id(&self) -> &usize {
                          &self.id
                      }

                      fn instance_id(&self) -> Option<&InstanceId> {
                          self.instance_id.as_ref()
                      }

                      fn entities(&self) -> &Vec<Entity> {
                         &self.entities
                      }
                  }
              }
          };
      }
    #+end_src

    这段代码创建了一个create_modular_segment的宏，用这个宏来生成ModularCharacterXx的组件，由于每个组件的写法基本相同，这个方法可以减少大重的冗余代码。

    在这个宏中，使用paste宏拼接了[<>]中的字符串，然后为这个Component生成ModularCharacter需要的方法
*** 使用Changed
    bevy中Changed用于减少对未修改组件的冗余操作
    #+begin_src rust-ts
      /// A filter on a component that only retains results the first time after they have been added or mutably dereferenced.
      ///
      /// A common use for this filter is avoiding redundant work when values have not changed.
      ///
      /// **Note** that simply *mutably dereferencing* a component is considered a change ([`DerefMut`](std::ops::DerefMut)).
      /// Bevy does not compare components to their previous values.
      ///
      /// To retain all results without filtering but still check whether they were changed after the
      /// system last ran, use [`Ref<T>`](crate::change_detection::Ref).
      ///
      /// **Note** that this includes changes that happened before the first time this `Query` was run.
      ///
      /// # Deferred
      ///
      /// Note, that entity modifications issued with [`Commands`](crate::system::Commands)
      /// (like entity creation or entity component addition or removal)
      /// are visible only after deferred operations are applied,
      /// typically at the end of the schedule iteration.
      ///
      /// # Time complexity
      ///
      /// `Changed` is not [`ArchetypeFilter`], which practically means that
      /// if query (with `T` component filter) matches million entities,
      /// `Changed<T>` filter will iterate over all of them even if none of them were changed.
      ///
      pub struct Changed<T>(PhantomData<T>);
    #+end_src

    通过其定义中的注释，可知该Changd标志直接判断某个被查询的Component的可变引用是否解引用。

    根据验证情况，简而言之，如果被Query的对象有重新赋值，则其被标识为Changed，不论赋值后的值与先前值是否相同。

    例如：
    #+begin_src rust-ts
      fn update_modular<T: components::ModularCharacter>(
          mut commands: Commands,
          mut changed_modular: Query<(Entity, &mut T), Changed<T>>,
          mesh_primitives_query: Query<MeshPrimitiveParamSet>,
          children: Query<&Children>,
          names: Query<&Name>,
          mut scene_spawner: ResMut<SceneSpawner>,
          mut writer: EventWriter<ResetChanged>,
      )

      fn cycle_modular_segment<T: ModularCharacter, const ID: usize>(
          mut modular: Query<&mut T>,
          key_input: Res<ButtonInput<KeyCode>>,
          mut scene_spawner: ResMut<SceneSpawner>,
          asset_server: Res<AssetServer>,
      ) {
          let Ok(mut module) = modular.get_single_mut() else {
              bevy::log::error!("Couldn't get single module.");
              return;
          };

          // deref mut
          ,*module.id_mut() = module.id().clone();
          return;

      }
    #+end_src

    modular.get_single_mut() 获取了可变引用，但是没有修改其值，Changed不置位。
    *module.id_mut() = module.id().clone() 尽管赋值前后值相同，但是有解引用操作，Changed会置位。
    
